import { FluxCore } from "../core/FluxCore";
import { Command } from "../shell/Command";
import { EXIT_CODES } from "../shell/FluxShell";
import { Libex } from "../utils/libex";

interface Ext {
	getLanTarget: (router: GreyHack.Router) => string;
}

const command = new Command<Ext>({
	name: "exploit",
	description: "Exploits and collects data from target",
	category: "Hacking",
	arguments: [
		{
			name: "ip",
			description: "The public or local IP of the target",
			required: false,
		},
		{
			name: "bounce_ip",
			description: "The local IP of the computer we're targeting through a router",
			required: false,
		}
	],
	options: [
		{
			name: "verbose",
			flags: ["-v", "--verbose"],
			description: "Show extra details",
		}
	],
	requirements: {
		hasShell: true
	}
});

command.funcs.getLanTarget = function (router) {
	const lanIPs = router.devicesLanIp();

	let out = "# LOCAL_IP";
	let index = 1;
	for (const ip of lanIPs) {
		out += `\\n${index} ${ip}`;
		index += 1;
	}
	print(formatColumns(out));

	let lanTarget = "";

	const input = userInput("Select local target for bounce attacks: ").toInt();
	if (isType(input, "number") && lanIPs.hasIndex(input - 1)) {
		lanTarget = lanIPs[input - 1];
	}

	if (!lanTarget && lanIPs.length) {
		lanTarget = lanIPs[0];
	}

	print("Selected: " + lanTarget);
	return lanTarget;
};

command.run = function (args, options, process) {
	const session = FluxCore.currSession();
	if (!session.metax) session.loadLibs();
	if (!session.metax) {
		process.write(2, "Current session doesn't have metax loaded");
		return EXIT_CODES.GENERAL_ERROR;
	}

	const oldSessionIds = Object.keys(FluxCore.raw.sessions);

	let target = session.localIp;
	if (args.length) target = args[0];

	let router = getRouter(target);
	let ports: GreyHack.Port[] | string = [];
	let lanTarget = "";
	const verbose = Object.hasOwn(options, "verbose");

	// Target is a router
	if (router) {
		ports = router.usedPorts();

		if (args.length > 1) lanTarget = args[1];
		if (!lanTarget) lanTarget = this.funcs.getLanTarget(router);

		const netSession = session.metax.netUse(target, 0);
		if (netSession) Libex.exploitLib(router.publicIp, netSession.dumpLib(), lanTarget, verbose);
	}

	// Exploit libs on host computer
	if (target === session.localIp || getRouter(session.localIp)) {
		if (getRouter(session.localIp) && !lanTarget) {
			lanTarget = this.funcs.getLanTarget(getRouter(session.localIp)!);
		}

		const libFolder = session.computer.file("/lib");
		if (libFolder) {
			for (const file of libFolder.getFiles()!) {
				const metaLib = session.metax.load(file.path())!;
				if (!metaLib) continue;

				Libex.exploitLib(session.publicIp, metaLib, lanTarget, verbose);
			}
		}
	}

	// Target is a device on the network
	if (isLanIp(target) && !router) {
		router = getRouter()!;
		ports = router.devicePorts(target)!;
	}

	if (isType(ports, "string")) {
		process.write(2, ports);
		return EXIT_CODES.GENERAL_ERROR;
	}

	if (!router) {
		process.write(2, "Failed to get router");
		return EXIT_CODES.GENERAL_ERROR;
	}

	for (const port of ports) {
		if (port.isClosed()) continue;

		const netSession = session.metax.netUse(target, port.portNumber);
		if (netSession) Libex.exploitLib(router.publicIp, netSession.dumpLib(), lanTarget, verbose);
	}

	let sessionsObtained = 0;
	for (const sessionId of Object.keys(FluxCore.raw.sessions)) {
		if (oldSessionIds.indexOf(sessionId) === null) {
			sessionsObtained++;
		}
	}

	process.write(1, `<color=#CC00FF>Collecting complete! Obtained ${sessionsObtained} new sessions.</color>`);
	return EXIT_CODES.SUCCESS;
};