import { Libex } from "../../utils/libex";
import { FluxCore } from "../core/FluxCore";
import { Command } from "../shell/Command";
import { EXIT_CODES } from "../shell/FluxShell";

const command = new Command({
	name: "exploit",
	description: "Exploits and collects data from target",
	category: "Hacking",
	arguments: [
		{
			name: "ip",
			description: "The public or local IP of the target",
			required: false,
		}
	],
	options: [
		{
			name: "verbose",
			flags: ["-v", "--verbose"],
			description: "Show extra details",
		}
	],
	requirements: {
		hasShell: true
	}
});

command.run = function (args, options, process) {
	const session = FluxCore.currSession();
	if (!session.metax) session.loadLibs();
	if (!session.metax) {
		process.write(2, "Current session doesn't have metax loaded");
		return EXIT_CODES.GENERAL_ERROR;
	}

	const oldSessionIds = Object.keys(FluxCore.raw.sessions);

	let target = session.localIp;
	if (args.length) {
		target = args[0];

		if (!isValidIp(target)) {
			process.write(2, `${target} is not a valid IP address`);
			return EXIT_CODES.GENERAL_ERROR;
		}
	};

	let router = getRouter(target);
	let ports: GreyHack.Port[] | string = [];
	const verbose = Object.hasOwn(options, "verbose");

	// Target is a router
	if (router) {
		ports = router.usedPorts();

		const netSession = session.metax.netUse(target, 0);
		if (netSession) {
			for (const lanIp of router.devicesLanIp()) {
				Libex.exploitLib(router.publicIp, netSession.dumpLib(), lanIp, verbose);
			}
		}
	}

	// Target is a device on the network
	if (isLanIp(target) && !router) {
		router = getRouter()!;
		ports = router.devicePorts(target)!;
	}

	if (!router) {
		process.write(2, "Failed to get router");
		return EXIT_CODES.GENERAL_ERROR;
	}

	// Exploit libs on host computer
	if (target === session.localIp) {
		const libFolder = session.computer.file("/lib");
		if (libFolder) {
			for (const file of libFolder.getFiles()!) {
				const metaLib = session.metax.load(file.path());
				if (!metaLib) continue;

				Libex.exploitLib(session.publicIp, metaLib, "", verbose);

				if (session.publicIp !== router.publicIp) continue;

				for (const lanIp of router.devicesLanIp())
					Libex.exploitLib(session.publicIp, metaLib, lanIp, verbose);
			}
		}
	}

	if (isType(ports, "string")) {
		process.write(2, ports);
		return EXIT_CODES.GENERAL_ERROR;
	}


	for (const port of ports) {
		if (port.isClosed()) continue;

		const netSession = session.metax.netUse(target, port.portNumber);
		if (!netSession) continue;

		for (const lanIp of router.devicesLanIp()) {
			Libex.exploitLib(router.publicIp, netSession.dumpLib(), lanIp, verbose);
		}
	}

	const sessionsObtained = Object.keys(FluxCore.raw.sessions).filter(id => !oldSessionIds.includes(id)).length;

	process.write(1, `<color=#CC00FF>Collecting complete! Obtained ${sessionsObtained} new sessions.</color>`);
	return EXIT_CODES.SUCCESS;
};